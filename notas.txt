CURSO NIVEL PRINCIPIANTE


ğŸ“… Fecha: 12/04/2025


ğŸ”¹ Generalidades

- ğŸ§  Python es un lenguaje excelente para el anÃ¡lisis de datos.  
- â• Trabaja muy bien con nÃºmeros.  
- ğŸ“š Dispone de muchas librerÃ­as populares: pandas, numpy, matplotlib, entre otras.

---

ğŸ› ï¸ Frameworks para desarrollo backend

- âš™ï¸ Django: framework robusto y completo.  
- ğŸ§© Flask: micro-framework, mÃ¡s ligero y flexible.  
- âš¡ FastAPI: relativamente nuevo (desde 2018), pero ha ganado popularidad por su rendimiento, asincronÃ­a y soporte de tipado.

---

ğŸ”„ Â¿QuÃ© es una API?

- ğŸŒ Una API permite la comunicaciÃ³n entre diferentes aplicaciones.  
- ğŸ“² Es la forma en que una web o app se conecta a un servidor o base de datos para intercambiar informaciÃ³n.  
- ğŸ”— Facilita la comunicaciÃ³n entre las diferentes capas de un sistema.

---

âš™ï¸ ConfiguraciÃ³n bÃ¡sica

- ğŸ’¬ Comentarios multilÃ­nea: usar tres comillas simples o dobles.  
- ğŸ§¾ Cadenas de texto: se definen con comillas simples ('texto') o dobles ("texto").  
- ğŸ§ type(valor): devuelve el tipo de dato (ej. type("python") â†’ <class 'str'>).

---

ğŸ“¦ Variables

- ğŸ§± ConvenciÃ³n: minÃºsculas y guiones bajos (snake_case). Ej: mi_variable  
- ğŸ–¨ï¸ print() acepta varios argumentos separados por comas.  
- ğŸ”„ str(valor): convierte un valor a string.

---

ğŸ§° Funciones del sistema

- ğŸ“ len(objeto): devuelve la longitud de listas, strings, etc.

---

ğŸ“ Tipado de variables

- ğŸŒ€ Python es de tipado dÃ©bil y dinÃ¡mico.  
- âœï¸ Se pueden usar anotaciones de tipo (no obligatorias):

  direccion: str = "mi direcciÃ³n"
  direccion = 32  # Se permite reasignar como int

---

â— Operadores

- â— DivisiÃ³n (/): nÃºmero decimal (float).  
- ğŸ”¢ DivisiÃ³n entera (//): solo la parte entera.  
- ğŸ§® MÃ³dulo (%): resto de la divisiÃ³n.  
- ğŸ”º Exponente (**): potencia.

---

ğŸ”˜ LÃ³gica booleana

- Operadores: and, or, not  
- ğŸ” Ejemplos:
  - False and False â†’ False
  - False or False â†’ False
  - False and True â†’ False
  - True or True â†’ True
  - True or False â†’ True
  - not True â†’ False
  - not False â†’ True

---

ğŸ“ Strings

- ğŸ“Œ Formato con f-string:

  print(f"Mi nombre es {nombre} {apellido} y mi edad es {edad}")

- ğŸ“¦ Desempaquetado de caracteres:

  a, b, c, d, e, f = "python"
  print(a)  # p
  print(b)  # y

- âœ‚ï¸ Slicing (substrings):

  cadena[1:3]  # devuelve posiciones 1 y 2

- ğŸ” Reverso de cadena:

  cadena[::-1]

- ğŸ› ï¸ MÃ©todos Ãºtiles:

  - capitalize(): primera letra mayÃºscula  
  - upper(): todo en mayÃºsculas  
  - lower(): todo en minÃºsculas  
  - isupper(): True si estÃ¡ en mayÃºsculas  
  - isnumeric(): True si es numÃ©rico  
  - count("t"): nÃºmero de veces que aparece "t"
"""

# Guardar en archivo txt
file_path = "/mnt/data/Python_para_principiantes.txt"
with open(file_path, "w", encoding="utf-8") as file:
    file.write(contenido)

file_path



ğŸ“… 13/04/2025  
ğŸ Python es un lenguaje orientado a objetos (POO)

ğŸ“‹ Listas

- Crear una lista:
  my_list = list()
  my_list = []

- CaracterÃ­sticas:
  - Las listas son estructuras dinÃ¡micas: permiten aÃ±adir, eliminar o modificar elementos.
  - Son diferentes de los arrays (mÃ¡s inmutables y restringidos en otros lenguajes como C o Java).

- Tuplas:
  - Se crean con tuple() o con ()
  - Ejemplo: my_tuple = tuple(), my_tuple = (1, 2, 3)
  - count(valor): cuenta cuÃ¡ntas veces aparece un valor en la tupla.

ğŸ”„ Desempaquetado de listas

- Se puede hacer si conoces el nÃºmero exacto de elementos:
  my_list = [25, "Juan", "PÃ©rez"]
  age, name, surname = my_list

â• ConcatenaciÃ³n de listas

- Se pueden sumar con +
  lista1 = [1, 2]
  lista2 = [3, 4]
  resultado = lista1 + lista2  # [1, 2, 3, 4]

â„¹ï¸ No existen constantes como tal en Python, pero por convenciÃ³n se escriben en mayÃºsculas:
  PI = 3.14159

âœ… MÃ©todos Ãºtiles de las listas:

- append(valor): aÃ±ade al final.
- insert(pos, valor): inserta en una posiciÃ³n especÃ­fica.
- remove(valor): elimina el primer valor encontrado.
- pop(): elimina y devuelve el Ãºltimo elemento.
- pop(pos): elimina y devuelve el elemento en la posiciÃ³n indicada.
- del lista[pos]: elimina un elemento sin retornarlo.
- clear(): borra todos los elementos de la lista.
- copy(): copia superficial de la lista.
- reverse(): invierte el orden.
- sort(): ordena (por defecto, de menor a mayor).

ğŸ“… 17/04/2025  
ğŸ”’ Tuplas

- DeclaraciÃ³n:
  my_tuple = tuple()
  my_other_tuple = (1, 2, 3)

- Inmutables: no se pueden modificar ni aÃ±adir elementos despuÃ©s de creadas.
- Se pueden concatenar: new_tuple = my_tuple + my_other_tuple
- Los slices ([inicio:fin]) funcionan como en las listas.
- Ãštiles cuando necesitas datos que no deben cambiar.
- Transformar tupla a lista: mi_lista = list(mi_tupla)
- Se puede eliminar una tupla entera con del, pero no sus elementos individuales.

ğŸ§º Sets (Conjuntos)

- Se crean con set() o con {}. âš ï¸ Ojo: {} vacÃ­o es un diccionario, no un set.

- CaracterÃ­sticas:
  - No tienen orden.
  - No permiten duplicados.
  - No se accede por Ã­ndice.
  - No admiten elementos mutables como listas dentro.

- MÃ©todos comunes:
  - add(valor): aÃ±ade un elemento.
  - union(set2): une dos sets.
  - difference(set2): diferencia entre sets.
  - clear(): borra todos los elementos.

ğŸ—‚ï¸ Diccionarios

- DeclaraciÃ³n:
  my_dict = dict()
  my_other_dict = {"clave": "valor"}

- Estructura desordenada de pares clave: valor.
  - La clave debe ser inmutable.
  - El valor puede ser cualquier tipo.

- Acceso por clave: my_dict["clave"]

- MÃ©todos y funciones Ãºtiles:
  - del my_dict["clave"]: elimina un par clave-valor.
  - "clave" in my_dict: comprueba si la clave existe.
  - keys(): devuelve todas las claves.
  - values(): devuelve todos los valores.
  - fromkeys(iterable): crea un diccionario con esas claves y valores None por defecto.
    claves = ["a", "b"]
    nuevo_dict = dict.fromkeys(claves)  # {'a': None, 'b': None}
    dict.fromkeys(claves, 0)  # {'a': 0, 'b': 0}


ğŸ“… 18/04/2025

## ğŸ”¹ Condicionales

- En Python, los condicionales permiten ejecutar cÃ³digo solo si se cumple una condiciÃ³n.
- Se utilizan las palabras clave `if`, `elif` y `else`.
- Si la condiciÃ³n del `if` es falsa, se evalÃºan los `elif` en orden. Si ninguno se cumple, se ejecuta el `else`.

```python
edad = 18

if edad < 18:
    print("Eres menor de edad")
elif edad == 18:
    print("Tienes 18 aÃ±os")
else:
    print("Eres mayor de edad")
```

ğŸ”¸ Detalles importantes a tener en cuenta:

- El bloque `else` no lleva condiciÃ³n.
- Los bloques deben ir indentados correctamente (por defecto 4 espacios o una tabulaciÃ³n).
- Las condiciones booleanas pueden encadenarse con `and`, `or`, `not`.
- Se pueden hacer comparaciones mÃºltiples:  
  `if 10 < x <= 20:` (muy comÃºn en Python).
- Cuidado con comparar cadenas (`str`), ya que la comparaciÃ³n es alfabÃ©tica.

---

## ğŸ” Bucles (loops/ciclos)

Permiten repetir un bloque de cÃ³digo varias veces.

### ğŸ”¸ `while`

- Ejecuta el bloque **mientras** la condiciÃ³n sea verdadera.
- Si se quiere un bucle infinito, se usa `while True`.
- Puede incluir un `else`, que se ejecuta cuando la condiciÃ³n ya no se cumple (raro en otros lenguajes).
- Se puede salir del bucle con `break`.

```python
x = 0
while x < 3:
    print(x)
    x += 1
else:
    print("Bucle terminado")
```

### ğŸ”¸ `for`

- Se usa para iterar sobre una **secuencia** (listas, tuplas, strings, diccionarios, etc.).
- MÃ¡s controlado que el `while`, porque recorre un nÃºmero definido de elementos.

```python
frutas = ["manzana", "plÃ¡tano", "uva"]
for fruta in frutas:
    print(fruta)
```

ğŸ”¹ En diccionarios:

```python
mi_dicc = {"a": 1, "b": 2}
for clave in mi_dicc:
    print(clave)  # Solo imprime la clave
    print(mi_dicc[clave])  # Valor asociado
```

ğŸ”¹ Instrucciones Ãºtiles:

- `break`: termina el bucle inmediatamente.
- `continue`: salta a la siguiente iteraciÃ³n sin ejecutar lo que queda.
- `else`: (opcional) se ejecuta si el bucle termina **sin** que haya un `break`.

---

## ğŸ”§ Funciones

- Permiten reutilizar cÃ³digo y resolver tareas especÃ­ficas encapsuladas.

### ğŸ”¸ DefiniciÃ³n

```python
def saludar(nombre):
    print(f"Hola, {nombre}")
```

### ğŸ”¸ Llamado

```python
saludar("Ana")  # Hola, Ana
```

ğŸ”¹ CaracterÃ­sticas:

- Se define con `def nombre_funcion(parÃ¡metros):`
- Se puede devolver un valor con `return`.
- Se pueden pasar parÃ¡metros por nombre en cualquier orden:
  
  ```python
  def mostrar_info(nombre, edad):
      print(f"{nombre} tiene {edad} aÃ±os")

  mostrar_info(edad=25, nombre="Luis")
  ```

- Se pueden usar parÃ¡metros variables con * nombre_variable (es un tipo de dato "tupla")

```python
def sumar_todo(*numeros):
    total = 0
    for n in numeros:
        total += n
    return total

print(sumar_todo(1, 2, 3))  # 6
```



ğŸ“† 19/4/2024

ğŸ”¹ CLASES

- Todo lo que pertenece a una clase debe responder a una lÃ³gica especÃ­fica relacionada con su entidad. Ej: una clase Person puede tener mÃ©todos como dormir(), andar(), etc.
- El objetivo es identificar nuestro cÃ³digo dentro de un Ã¡mbito de actuaciÃ³n (abstracciÃ³n).
- Las clases se definen con la palabra clave `class` y, por buenas prÃ¡cticas, se nombran en CamelCase.

class MyPerson:
    pass

- El `pass` se usa para dejar un bloque vacÃ­o sin que genere error.
- Podemos imprimir una clase o una instancia de ella:

print(MyPerson)      # Muestra que es una clase
print(MyPerson())    # Muestra que es una instancia

- `__init__(self)`: es el constructor, se ejecuta al crear una instancia. `self` hace referencia al objeto que se estÃ¡ creando.
- Es mala prÃ¡ctica mezclar funciones sueltas y clases en un mismo archivo grande. Se recomienda modularizar.

ğŸ”’ VARIABLES PRIVADAS

- Las variables privadas en Python no son verdaderamente privadas, pero se nombran con doble guion bajo `__`.

class Persona:
    def __init__(self, nombre):
        self.nombre = nombre           # pÃºblica
        self.__edad = 30               # privada

    def get_edad(self):
        return self.__edad

persona = Persona("Diego")
print(persona.nombre)
print(persona.get_edad())  # Correcto

ğŸ”¹ EXCEPCIONES

- Sirven para manejar errores que de otro modo harÃ­an que el programa se detenga inesperadamente.
- Uso bÃ¡sico:

try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("No se puede dividir entre cero.")

- Estructura completa:

try:
    x = int("hola")
except ValueError as e:
    print("Error de valor:", e)
else:
    print("Todo saliÃ³ bien.")
finally:
    print("Esto se ejecuta siempre.")

- `else`: se ejecuta si no hay error.
- `finally`: se ejecuta siempre, ocurra error o no.
- Puedes capturar errores especÃ­ficos usando `except TipoDeError as variable`.

ğŸ”¹ MÃ“DULOS

- Un mÃ³dulo es cualquier archivo `.py` con funciones, clases o variables reutilizables.
- Ideal para mantener el cÃ³digo organizado y escalable.

# archivo: herramientas.py
def saludar():
    print("Hola desde otro archivo")

# archivo principal
import herramientas
herramientas.saludar()

- TambiÃ©n puedes importar solo lo necesario:

from math import sqrt, pi
print(sqrt(16), pi)

- Python incluye mÃ³dulos por defecto como `math`, `random`, `datetime`, etc.

ğŸ“† 21/4/2024 

CURSO NIVEL INTERMEDIO

ğŸ”¹ FECHAS (datetime)

from datetime import datetime, date, time, timedelta

ahora = datetime.now()
hoy = date.today()
hora = time(14, 30)
maniana = hoy + timedelta(days=1)

- datetime: representa fecha y hora.
- date: solo fecha.
- time: solo hora.
- timedelta: operaciones con fechas.
- Solo se pueden restar objetos del mismo tipo (date - date, datetime - datetime).
- timestamp(): devuelve formato POSIX (segundos desde 1/1/1970).

ğŸ”¹ LIST COMPREHENSION

Forma compacta de crear listas.

cuadrados = [x**2 for x in range(5)]
pares = [x for x in range(10) if x % 2 == 0]

ğŸ”¹ LAMBDAS

Funciones anÃ³nimas de una sola lÃ­nea.

sumar = lambda a, b: a + b
print(sumar(3, 5))

ğŸ”¹ FUNCIONES DE ORDEN SUPERIOR

Funciones que reciben otras funciones como parÃ¡metro.

map():
numeros = [1, 2, 3]
dobles = list(map(lambda x: x * 2, numeros))

filter():
pares = list(filter(lambda x: x % 2 == 0, numeros))

reduce():
from functools import reduce
suma = reduce(lambda x, y: x + y, numeros)

ğŸ”¹ CLOSURES

Funciones internas que recuerdan el estado del entorno donde fueron creadas.

def saludar(nombre):
    def mensaje():
        return f"Hola, {nombre}"
    return mensaje

saludo = saludar("Diego")
print(saludo())  # Hola, Diego